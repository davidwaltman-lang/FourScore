<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Chain Dominoes – Play</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:#f8fafc;margin:0;padding:20px;}
  .card{max-width:980px;margin:auto;background:#fff;border:1px solid #e5e7eb;border-radius:16px;padding:16px;}
  h2{margin:0 0 6px 0;}
  .small{font-size:12px;color:#6b7280;}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;}
  button{padding:10px 14px;border-radius:12px;border:1px solid #d1d5db;background:#f9fafb;font-weight:750;cursor:pointer;}
  button.primary{background:#111827;color:#fff;border-color:#111827;}
  button.danger{background:#fff1f2;border-color:#fecdd3;}
  .divider{height:1px;background:#e5e7eb;margin:14px 0;}

  .anchorRow{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:10px;}
  .anchor{
    border:1px solid #d1d5db;border-radius:14px;padding:10px 12px;background:#f3f4f6;
    font-weight:850; flex:1 1 320px;
  }

  /* Progress */
  .progressWrap{
    margin-top:8px;
    border:1px solid #e5e7eb;
    border-radius:14px;
    padding:10px 12px;
    background:#fafafa;
    display:flex;
    gap:12px;
    align-items:center;
    justify-content:space-between;
    flex-wrap:wrap;
  }
  .barOuter{
    flex:1 1 320px;
    height:12px;
    border-radius:999px;
    background:#e5e7eb;
    overflow:hidden;
  }
  .barInner{
    height:100%;
    width:0%;
    background:#111827;
  }
  .metric{font-size:12px;color:#111827;font-weight:850;}
  .note{font-size:12px;color:#6b7280;}

  /* Chain = single column */
  .chainWrap{
    border:1px solid #e5e7eb;
    border-radius:14px;
    background:#fafafa;
    padding:10px;
  }
  .chain{display:flex;flex-direction:column;gap:10px;}
  .slot{
    border:2px dashed #cbd5e1;
    border-radius:14px;
    background:#f8fafc;
    min-height:86px;
    display:flex;
    align-items:stretch;
    justify-content:stretch;
    overflow:hidden;
  }
  .slot.over{border-color:#111827;}
  .slot.filled{border-style:solid;border-color:#e5e7eb;background:#fff;}
  .slotLabel{
    width:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:12px;
    color:#94a3b8;
    font-size:12px;
    font-weight:800;
    text-align:center;
  }

  /* Tile */
  .tileWrap{
    width:100%;
    padding:10px;
    display:flex;
    gap:10px;
    align-items:center;
    user-select:none;
  }
  .tileCore{
    flex:1 1 auto;
    display:flex;
    gap:10px;
    align-items:center;
    border:1px solid #d1d5db;
    border-radius:14px;
    padding:10px;
    background:#fff;
    min-width:0;
  }
  .half{
    flex:1 1 0;
    text-align:center;
    font-weight:900;
    padding:10px;
    border-radius:12px;
    background:#f3f4f6;
    min-width:0;
    word-break:break-word;
  }
  .sep{width:2px;height:44px;background:#e5e7eb;border-radius:2px;flex:0 0 auto;}
  .tileBtns{display:flex;gap:8px;align-items:center;flex:0 0 auto;}
  .miniBtn{
    border:1px solid #d1d5db;background:#f9fafb;border-radius:12px;
    padding:8px 10px;font-weight:900;cursor:pointer;
  }
  .draggable{cursor:grab;}
  .draggable:active{cursor:grabbing;}
  .selected{outline:3px solid #111827; outline-offset:2px; border-radius:16px;}

  /* Bank */
  .bankWrap{
    border:1px solid #e5e7eb;
    border-radius:14px;
    background:#fafafa;
    padding:10px;
  }
  .bankGrid{
    display:grid;
    grid-template-columns:repeat(2, minmax(0,1fr));
    gap:10px;
  }
  @media (max-width: 760px){
    .bankGrid{grid-template-columns:repeat(1, minmax(0,1fr));}
  }

  /* Feedback + toast */
  .feedback{margin-top:10px;padding:10px 12px;border-radius:12px;background:#f3f4f6;color:#111827;font-size:13px;}
  .ok{background:#ecfdf5;}
  .bad{background:#fff1f2;}
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;}

  .toast{
    position:fixed;
    left:50%;
    bottom:16px;
    transform:translateX(-50%);
    background:#111827;
    color:#fff;
    padding:10px 12px;
    border-radius:999px;
    font-size:12px;
    font-weight:800;
    opacity:0;
    pointer-events:none;
    transition:opacity .18s ease;
  }
  .toast.show{opacity:1;}
</style>
</head>
<body>

<div class="card">
  <div class="row">
    <div>
      <h2>Chain Dominoes</h2>
      <div class="small" id="sub">Drag tiles into the chain, or tap a tile then tap a slot.</div>

      <div class="progressWrap">
        <div class="metric" id="metricText">Correct connections: 0 / 0</div>
        <div class="barOuter"><div class="barInner" id="barInner"></div></div>
        <div class="note" id="noteText">Fill slots to see progress.</div>
      </div>
    </div>

    <div class="row" style="justify-content:flex-end;">
      <button onclick="shuffleBank()">Shuffle bank</button>
      <button class="danger" onclick="resetAll()">Reset</button>
      <button class="primary" onclick="checkChain()">Check</button>
    </div>
  </div>

  <div class="divider"></div>

  <div id="anchors" class="anchorRow" style="display:none;">
    <div class="anchor" id="startAnchor"></div>
    <div class="anchor" id="endAnchor"></div>
  </div>

  <div class="small" style="margin-bottom:6px;">Chain (top → bottom):</div>
  <div class="chainWrap">
    <div id="slots" class="chain"></div>
  </div>

  <div class="divider"></div>

  <div class="row" style="margin-bottom:6px;">
    <div class="small">Tile bank:</div>
    <div class="small">Tip: Tap tile → tap slot (touch-friendly).</div>
  </div>
  <div class="bankWrap">
    <div id="bank" class="bankGrid"></div>
  </div>

  <div id="feedback" class="feedback" style="display:none;"></div>
</div>

<div class="toast" id="toast"></div>

<script>
  function decodeB64Unicode(b64){
    try { return decodeURIComponent(escape(atob(b64))); } catch(e){ return null; }
  }
  function shuffle(arr){
    for (let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    return arr;
  }
  const norm = s => (s||"").trim().toLowerCase();
  const eq = (a,b) => norm(a) === norm(b);

  const m = (location.hash || "").match(/#p=([^&]+)/);
  if (!m) { document.getElementById("sub").textContent = "Missing game data in the link."; throw ""; }
  const raw = decodeB64Unicode(m[1]);
  if (!raw) { document.getElementById("sub").textContent = "Could not read game data."; throw ""; }

  const payload = JSON.parse(raw);
  const steps = (payload.steps || []).map(s => (s||"").trim()).filter(Boolean);
  const showAnchors = !!payload.showAnchors;
  const allowFlip = (payload.allowFlip !== false);

  if (steps.length < 3){
    document.getElementById("sub").textContent = "Invalid chain (needs at least 3 steps).";
    throw "";
  }

  // Answer tiles
  const answerTiles = [];
  for (let i=0;i<steps.length-1;i++){
    answerTiles.push({ id:"t"+(i+1), left:steps[i], right:steps[i+1] });
  }
  const expectedStart = steps[0];
  const expectedEnd = steps[steps.length-1];

  // State
  let bankTiles = shuffle(answerTiles.map(t => ({...t})));
  let chain = Array(answerTiles.length).fill(null);
  let selectedId = null;

  const slotsEl = document.getElementById("slots");
  const bankEl = document.getElementById("bank");
  const fbEl = document.getElementById("feedback");
  const metricText = document.getElementById("metricText");
  const noteText = document.getElementById("noteText");
  const barInner = document.getElementById("barInner");
  const toastEl = document.getElementById("toast");

  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add("show");
    setTimeout(()=>toastEl.classList.remove("show"), 1100);
  }

  function showFeedback(html, kind){
    fbEl.style.display = "block";
    fbEl.className = "feedback " + (kind || "");
    fbEl.innerHTML = html;
  }
  function clearFeedback(){
    fbEl.style.display = "none";
    fbEl.className = "feedback";
    fbEl.innerHTML = "";
  }

  function flipTileById(id){
    let t = bankTiles.find(x => x.id === id);
    if (t){ [t.left,t.right]=[t.right,t.left]; render(); return; }
    for (let i=0;i<chain.length;i++){
      if (chain[i] && chain[i].id === id){
        [chain[i].left,chain[i].right]=[chain[i].right,chain[i].left];
        render(); return;
      }
    }
  }

  function setSelected(id){
    selectedId = (selectedId === id) ? null : id;
    render();
  }

  function getTileById(id){
    let t = bankTiles.find(x=>x.id===id);
    if (t) return t;
    t = chain.find(x=>x && x.id===id);
    return t || null;
  }

  function neighborScoreAt(slotIdx, tile){
    // Score is how well tile fits with already-placed neighbors
    // Left neighbor = chain[slotIdx-1], compare neighbor.right to tile.left
    // Right neighbor = chain[slotIdx+1], compare tile.right to neighbor.left
    let score = 0;
    const leftN = (slotIdx > 0) ? chain[slotIdx-1] : null;
    const rightN = (slotIdx < chain.length-1) ? chain[slotIdx+1] : null;

    if (leftN) score += eq(leftN.right, tile.left) ? 1 : 0;
    if (rightN) score += eq(tile.right, rightN.left) ? 1 : 0;

    // If anchors are on, also reward matching start/end at extremes
    if (showAnchors){
      if (slotIdx === 0) score += eq(tile.left, expectedStart) ? 1 : 0;
      if (slotIdx === chain.length-1) score += eq(tile.right, expectedEnd) ? 1 : 0;
    }
    return score;
  }

  function bestEmptySlotForTile(tile){
    let best = { idx:null, score:-1 };
    for (let i=0;i<chain.length;i++){
      if (chain[i]) continue;
      const s = neighborScoreAt(i, tile);
      if (s > best.score){
        best = { idx:i, score:s };
      }
    }
    return best;
  }

  function removeTileFromWherever(id){
    // Remove from bank
    const bi = bankTiles.findIndex(t=>t.id===id);
    if (bi !== -1) return bankTiles.splice(bi,1)[0];

    // Remove from chain
    const si = chain.findIndex(t=>t && t.id===id);
    if (si !== -1){
      const t = chain[si];
      chain[si] = null;
      return t;
    }
    return null;
  }

  function placeTileInSlot(id, idx){
    clearFeedback();

    const moving = removeTileFromWherever(id);
    if (!moving) return;

    // If slot occupied, bump it to bank
    if (chain[idx]) bankTiles.push(chain[idx]);

    chain[idx] = moving;
    selectedId = null;

    // AUTO-SNAP: if there is a better empty slot, move it there
    // (Only if current score is 0 and a better slot exists with score >=1)
    const hereScore = neighborScoreAt(idx, moving);
    const best = bestEmptySlotForTile(moving);

    if (hereScore === 0 && best.idx !== null && best.score >= 1){
      // move to better slot
      chain[idx] = null;
      chain[best.idx] = moving;
      toast("Auto-snapped to a better fit ✅");
    }

    render();
  }

  function returnTileToBank(slotIdx){
    if (!chain[slotIdx]) return;
    bankTiles.push(chain[slotIdx]);
    chain[slotIdx] = null;
    render();
  }

  function makeTileUI(tile, where, slotIdx){
    const wrap = document.createElement("div");
    wrap.className = "tileWrap draggable";
    if (selectedId === tile.id) wrap.classList.add("selected");
    wrap.draggable = true;
    wrap.dataset.id = tile.id;

    const core = document.createElement("div");
    core.className = "tileCore";

    const L = document.createElement("div"); L.className="half"; L.textContent = tile.left;
    const sep = document.createElement("div"); sep.className="sep";
    const R = document.createElement("div"); R.className="half"; R.textContent = tile.right;

    core.appendChild(L); core.appendChild(sep); core.appendChild(R);

    const btns = document.createElement("div");
    btns.className = "tileBtns";

    if (allowFlip){
      const flip = document.createElement("button");
      flip.className = "miniBtn";
      flip.textContent = "↔";
      flip.title = "Flip tile";
      flip.onclick = (e)=>{ e.stopPropagation(); flipTileById(tile.id); };
      btns.appendChild(flip);
      wrap.ondblclick = ()=>flipTileById(tile.id);
    }

    if (where === "slot"){
      const back = document.createElement("button");
      back.className = "miniBtn";
      back.textContent = "↩";
      back.title = "Return to bank";
      back.onclick = (e)=>{ e.stopPropagation(); returnTileToBank(slotIdx); };
      btns.appendChild(back);
    }

    wrap.onclick = (e)=>{
      if (e.target && e.target.tagName === "BUTTON") return;
      setSelected(tile.id);
    };

    wrap.addEventListener("dragstart", (e)=>{
      e.dataTransfer.setData("text/plain", tile.id);
      e.dataTransfer.effectAllowed = "move";
    });

    wrap.appendChild(core);
    wrap.appendChild(btns);
    return wrap;
  }

  function computeProgress(){
    // Total connections = chain.length-1, plus optional start/end anchor checks (if enabled)
    const totalConnections = Math.max(0, chain.length - 1);
    let correct = 0;
    let filledPairsCounted = 0;

    // Adjacent correctness (count only where both tiles exist)
    for (let i=0;i<chain.length-1;i++){
      if (!chain[i] || !chain[i+1]) continue;
      filledPairsCounted++;
      if (eq(chain[i].right, chain[i+1].left)) correct++;
    }

    // Anchors (optional, only if slot 0 or last filled)
    let anchorTotal = 0;
    let anchorCorrect = 0;
    if (showAnchors){
      anchorTotal = 2;
      if (chain[0]) anchorCorrect += eq(chain[0].left, expectedStart) ? 1 : 0;
      if (chain[chain.length-1]) anchorCorrect += eq(chain[chain.length-1].right, expectedEnd) ? 1 : 0;
    }

    const total = totalConnections + anchorTotal;
    const got = correct + anchorCorrect;

    // For the bar, we show progress out of total possible checks, but note if not all are currently “checkable”
    return {
      total,
      got,
      filledPairsCounted,
      totalConnections,
      anchorTotal,
      anchorCorrect
    };
  }

  function renderProgress(){
    const p = computeProgress();
    metricText.textContent = `Correct connections: ${p.got} / ${p.total}`;

    const pct = (p.total === 0) ? 0 : Math.round((p.got / p.total) * 100);
    barInner.style.width = pct + "%";

    const filledSlots = chain.filter(Boolean).length;
    if (filledSlots === 0){
      noteText.textContent = "Fill slots to see progress.";
    } else if (filledSlots < chain.length){
      noteText.textContent = `Placed ${filledSlots}/${chain.length} tiles. Progress updates as neighbors touch.`;
    } else {
      noteText.textContent = "All tiles placed — hit Check for final verification.";
    }
  }

  function render(){
    // Anchors
    const anchors = document.getElementById("anchors");
    if (showAnchors){
      anchors.style.display = "flex";
      document.getElementById("startAnchor").textContent = "START: " + expectedStart;
      document.getElementById("endAnchor").textContent = "END: " + expectedEnd;
    } else {
      anchors.style.display = "none";
    }

    // Slots
    slotsEl.innerHTML = "";
    chain.forEach((tile, idx)=>{
      const slot = document.createElement("div");
      slot.className = "slot" + (tile ? " filled" : "");
      slot.dataset.slot = String(idx);

      slot.addEventListener("dragover", (e)=>{ e.preventDefault(); slot.classList.add("over"); });
      slot.addEventListener("dragleave", ()=>slot.classList.remove("over"));
      slot.addEventListener("drop", (e)=>{
        e.preventDefault(); slot.classList.remove("over");
        const id = e.dataTransfer.getData("text/plain");
        placeTileInSlot(id, idx);
      });

      slot.onclick = ()=>{
        if (selectedId) placeTileInSlot(selectedId, idx);
      };

      if (tile){
        slot.appendChild(makeTileUI(tile, "slot", idx));
      } else {
        const ph = document.createElement("div");
        ph.className = "slotLabel";
        ph.textContent = selectedId ? "Tap to place selected tile here" : ("Slot " + (idx+1));
        slot.appendChild(ph);
      }

      slotsEl.appendChild(slot);
    });

    // Bank
    bankEl.innerHTML = "";
    bankTiles.forEach(t => bankEl.appendChild(makeTileUI(t, "bank", -1)));

    renderProgress();
  }

  function shuffleBank(){
    bankTiles = shuffle(bankTiles);
    render();
  }

  function resetAll(){
    clearFeedback();
    selectedId = null;
    chain = Array(answerTiles.length).fill(null);
    bankTiles = shuffle(answerTiles.map(t => ({...t})));
    render();
  }

  function checkChain(){
    clearFeedback();

    if (chain.some(x => !x)){
      showFeedback("Fill every slot before checking.", "bad");
      return;
    }

    const wrongAfter = [];
    for (let i=0;i<chain.length-1;i++){
      if (!eq(chain[i].right, chain[i+1].left)) wrongAfter.push(i);
    }

    if (showAnchors){
      if (!eq(chain[0].left, expectedStart)) wrongAfter.push(-1);
      if (!eq(chain[chain.length-1].right, expectedEnd)) wrongAfter.push(chain.length-1);
    }

    if (wrongAfter.length === 0){
      showFeedback("✅ Nice! Chain rebuilt correctly.", "ok");
      return;
    }

    const mid = wrongAfter.filter(x=>x>=0);
    const parts = [];
    parts.push(`<b>Not quite.</b>`);
    if (mid.length){
      parts.push(`<div class="small mono">Mismatch after tile(s): ${mid.map(i=>i+1).join(", ")}</div>`);
    }
    if (showAnchors){
      if (wrongAfter.includes(-1)) parts.push(`<div class="small mono">Start tile left side doesn’t match START.</div>`);
      if (wrongAfter.includes(chain.length-1)) parts.push(`<div class="small mono">End tile right side doesn’t match END.</div>`);
    }
    parts.push(`<div class="small">Tip: swap positions (and flip tiles if enabled). Auto-snap helps when neighbors are already placed.</div>`);
    showFeedback(parts.join(""), "bad");
  }

  document.getElementById("sub").textContent = allowFlip
    ? "Drag tiles into the chain, or tap a tile then tap a slot. Double-click a tile (or ↔) to flip."
    : "Drag tiles into the chain, or tap a tile then tap a slot.";

  render();
</script>

</body>
</html>
