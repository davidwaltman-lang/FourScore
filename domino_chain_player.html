<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Chain Dominoes – Train Mode</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:#f8fafc;margin:0;padding:20px;}
  .card{max-width:1100px;margin:auto;background:#fff;border:1px solid #e5e7eb;border-radius:16px;padding:16px;}
  h2{margin:0 0 6px 0;}
  .small{font-size:12px;color:#6b7280;}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;}
  button{padding:10px 14px;border-radius:12px;border:1px solid #d1d5db;background:#f9fafb;font-weight:750;cursor:pointer;}
  button.primary{background:#111827;color:#fff;border-color:#111827;}
  button.danger{background:#fff1f2;border-color:#fecdd3;}
  .divider{height:1px;background:#e5e7eb;margin:14px 0;}

  .progressWrap{
    margin-top:8px;
    border:1px solid #e5e7eb;
    border-radius:14px;
    padding:10px 12px;
    background:#fafafa;
    display:flex;
    gap:12px;
    align-items:center;
    justify-content:space-between;
    flex-wrap:wrap;
  }
  .barOuter{flex:1 1 320px;height:12px;border-radius:999px;background:#e5e7eb;overflow:hidden;}
  .barInner{height:100%;width:0%;background:#111827;}
  .metric{font-size:12px;color:#111827;font-weight:900;}
  .note{font-size:12px;color:#6b7280;}

  .anchorRow{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:10px;}
  .anchor{border:1px solid #d1d5db;border-radius:14px;padding:10px 12px;background:#f3f4f6;font-weight:900;flex:1 1 320px;}

  /* Train area */
  .trainWrap{border:1px solid #e5e7eb;border-radius:14px;background:#fafafa;padding:12px;}
  .trainTop{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;margin-bottom:10px;}
  .endBox{
    border:2px dashed #cbd5e1;border-radius:14px;background:#f8fafc;
    padding:10px 12px;min-width:260px;flex:1 1 260px;
  }
  .endBox.over{border-color:#111827;}
  .endLabel{font-size:12px;color:#64748b;font-weight:900;margin-bottom:6px;}
  .endValue{font-size:14px;color:#111827;font-weight:900;word-break:break-word;}
  .endHint{font-size:12px;color:#6b7280;margin-top:6px;}

  .train{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:stretch;
  }

  /* Tile */
  .tileWrap{
    display:flex;
    gap:8px;
    align-items:center;
    user-select:none;
  }
  .tileCore{
    width:320px;
    max-width:100%;
    display:flex;
    gap:10px;
    align-items:center;
    border:1px solid #d1d5db;
    border-radius:14px;
    padding:10px;
    background:#fff;
    min-width:0;
  }
  .half{
    flex:1 1 0;
    text-align:center;
    font-weight:900;
    padding:10px;
    border-radius:12px;
    background:#f3f4f6;
    min-width:0;
    word-break:break-word;
  }
  .sep{width:2px;height:44px;background:#e5e7eb;border-radius:2px;flex:0 0 auto;}
  .tileBtns{display:flex;gap:8px;align-items:center;flex:0 0 auto;}
  .miniBtn{border:1px solid #d1d5db;background:#f9fafb;border-radius:12px;padding:8px 10px;font-weight:900;cursor:pointer;}

  .draggable{cursor:grab;}
  .draggable:active{cursor:grabbing;}
  .selected{outline:3px solid #111827; outline-offset:2px; border-radius:16px;}

  /* Bank */
  .bankWrap{border:1px solid #e5e7eb;border-radius:14px;background:#fafafa;padding:12px;}
  .bankGrid{display:grid;grid-template-columns:repeat(3, minmax(0,1fr));gap:10px;}
  @media (max-width: 980px){ .bankGrid{grid-template-columns:repeat(2, minmax(0,1fr));} }
  @media (max-width: 680px){ .bankGrid{grid-template-columns:repeat(1, minmax(0,1fr));} }

  .feedback{margin-top:10px;padding:10px 12px;border-radius:12px;background:#f3f4f6;color:#111827;font-size:13px;}
  .ok{background:#ecfdf5;}
  .bad{background:#fff1f2;}
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;}

  .toast{
    position:fixed;left:50%;bottom:16px;transform:translateX(-50%);
    background:#111827;color:#fff;padding:10px 12px;border-radius:999px;
    font-size:12px;font-weight:900;opacity:0;pointer-events:none;transition:opacity .18s ease;
  }
  .toast.show{opacity:1;}
</style>
</head>
<body>

<div class="card">
  <div class="row">
    <div>
      <h2>Domino Train</h2>
      <div class="small" id="sub">Play tiles only on the LEFT or RIGHT end. Drag or tap-to-play.</div>

      <div class="progressWrap">
        <div class="metric" id="metricText">Correct links in train: 0 / 0</div>
        <div class="barOuter"><div class="barInner" id="barInner"></div></div>
        <div class="note" id="noteText">Build the train by matching ends.</div>
      </div>
    </div>

    <div class="row" style="justify-content:flex-end;">
      <button onclick="shuffleBank()">Shuffle bank</button>
      <button class="danger" onclick="resetAll()">Reset</button>
      <button class="primary" onclick="checkTrain()">Check</button>
    </div>
  </div>

  <div class="divider"></div>

  <div id="anchors" class="anchorRow" style="display:none;">
    <div class="anchor" id="startAnchor"></div>
    <div class="anchor" id="endAnchor"></div>
  </div>

  <div class="small" style="margin-bottom:6px;">Train (tiles you’ve played):</div>
  <div class="trainWrap">
    <div class="trainTop">
      <div id="leftEnd" class="endBox">
        <div class="endLabel">LEFT END</div>
        <div class="endValue" id="leftValue"></div>
        <div class="endHint">Drop a tile here (or tap here after selecting a tile).</div>
      </div>
      <div id="rightEnd" class="endBox">
        <div class="endLabel">RIGHT END</div>
        <div class="endValue" id="rightValue"></div>
        <div class="endHint">Drop a tile here (or tap here after selecting a tile).</div>
      </div>
    </div>

    <div id="train" class="train"></div>
  </div>

  <div class="divider"></div>

  <div class="row" style="margin-bottom:6px;">
    <div class="small">Tile bank:</div>
    <div class="small">Tip: Tap a tile → tap LEFT END or RIGHT END.</div>
  </div>
  <div class="bankWrap">
    <div id="bank" class="bankGrid"></div>
  </div>

  <div id="feedback" class="feedback" style="display:none;"></div>
</div>

<div class="toast" id="toast"></div>

<script>
  function decodeB64Unicode(b64){
    try { return decodeURIComponent(escape(atob(b64))); } catch(e){ return null; }
  }
  function shuffle(arr){
    for (let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    return arr;
  }
  const norm = s => (s||"").trim().toLowerCase();
  const eq = (a,b) => norm(a) === norm(b);

  const m = (location.hash || "").match(/#p=([^&]+)/);
  if (!m) { document.getElementById("sub").textContent = "Missing game data in the link."; throw ""; }
  const raw = decodeB64Unicode(m[1]);
  if (!raw) { document.getElementById("sub").textContent = "Could not read game data."; throw ""; }

  const payload = JSON.parse(raw);
  const steps = (payload.steps || []).map(s => (s||"").trim()).filter(Boolean);
  const showAnchors = !!payload.showAnchors;
  const allowFlip = (payload.allowFlip !== false);

  if (steps.length < 3){
    document.getElementById("sub").textContent = "Invalid chain (needs at least 3 steps).";
    throw "";
  }

  // Answer tiles: consecutive steps
  const answerTiles = [];
  for (let i=0;i<steps.length-1;i++){
    answerTiles.push({ id:"t"+(i+1), left:steps[i], right:steps[i+1] });
  }
  const expectedStart = steps[0];
  const expectedEnd = steps[steps.length-1];

  // State
  let bankTiles, trainTiles, selectedId;

  const trainEl = document.getElementById("train");
  const bankEl = document.getElementById("bank");
  const fbEl = document.getElementById("feedback");
  const metricText = document.getElementById("metricText");
  const noteText = document.getElementById("noteText");
  const barInner = document.getElementById("barInner");
  const toastEl = document.getElementById("toast");
  const leftEndEl = document.getElementById("leftEnd");
  const rightEndEl = document.getElementById("rightEnd");
  const leftValueEl = document.getElementById("leftValue");
  const rightValueEl = document.getElementById("rightValue");

  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add("show");
    setTimeout(()=>toastEl.classList.remove("show"), 1100);
  }
  function showFeedback(html, kind){
    fbEl.style.display = "block";
    fbEl.className = "feedback " + (kind || "");
    fbEl.innerHTML = html;
  }
  function clearFeedback(){
    fbEl.style.display = "none";
    fbEl.className = "feedback";
    fbEl.innerHTML = "";
  }

  function flip(tile){ [tile.left, tile.right] = [tile.right, tile.left]; }

  function setSelected(id){
    selectedId = (selectedId === id) ? null : id;
    render();
  }

  function getOpenEnds(){
    // Train left end is trainTiles[0].left, right end is last.right
    const left = trainTiles[0].left;
    const right = trainTiles[trainTiles.length-1].right;
    return { left, right };
  }

  function canPlayOnLeft(tile){
    const ends = getOpenEnds();
    return eq(tile.right, ends.left); // tile.right touches left end
  }
  function canPlayOnRight(tile){
    const ends = getOpenEnds();
    return eq(tile.left, ends.right); // tile.left touches right end
  }

  function removeFromBank(id){
    const i = bankTiles.findIndex(t=>t.id===id);
    if (i===-1) return null;
    return bankTiles.splice(i,1)[0];
  }

  function attemptPlay(id, side){
    clearFeedback();
    const tile = removeFromBank(id);
    if (!tile) return;

    // Try without flip first; if not playable, try flip (if allowed)
    let played = false;

    const tryLeft = () => {
      if (canPlayOnLeft(tile)) { trainTiles.unshift(tile); played=true; return; }
    };
    const tryRight = () => {
      if (canPlayOnRight(tile)) { trainTiles.push(tile); played=true; return; }
    };

    if (side === "left"){
      tryLeft();
      if (!played && allowFlip){ flip(tile); tryLeft(); }
    } else {
      tryRight();
      if (!played && allowFlip){ flip(tile); tryRight(); }
    }

    if (!played){
      // Put it back
      bankTiles.push(tile);
      toast("No match on that end ❌");
      render();
      return;
    }

    selectedId = null;
    toast("Played ✅");
    render();
  }

  function computeProgress(){
    // Correct links = number of correct adjacent joins inside the train
    let correct = 0;
    for (let i=0;i<trainTiles.length-1;i++){
      if (eq(trainTiles[i].right, trainTiles[i+1].left)) correct++;
    }
    const total = answerTiles.length; // in a full chain with N tiles, there are N-1 joins; but our goal is N-1 joins.
    const joinsTotal = Math.max(0, answerTiles.length - 1);

    // We report joins correct out of joinsTotal (more intuitive)
    return { correct, joinsTotal };
  }

  function renderProgress(){
    const p = computeProgress();
    metricText.textContent = `Correct links in train: ${p.correct} / ${p.joinsTotal}`;

    const pct = (p.joinsTotal === 0) ? 0 : Math.round((p.correct / p.joinsTotal) * 100);
    barInner.style.width = pct + "%";

    if (bankTiles.length > 0){
      noteText.textContent = `Tiles remaining: ${bankTiles.length}. You can only play on the ends.`;
    } else {
      noteText.textContent = "All tiles played — hit Check.";
    }
  }

  function makeTileUI(tile, where){
    const wrap = document.createElement("div");
    wrap.className = "tileWrap draggable";
    if (where==="bank" && selectedId === tile.id) wrap.classList.add("selected");
    wrap.draggable = (where==="bank");
    wrap.dataset.id = tile.id;

    const core = document.createElement("div");
    core.className = "tileCore";

    const L = document.createElement("div"); L.className="half"; L.textContent = tile.left;
    const sep = document.createElement("div"); sep.className="sep";
    const R = document.createElement("div"); R.className="half"; R.textContent = tile.right;

    core.appendChild(L); core.appendChild(sep); core.appendChild(R);

    const btns = document.createElement("div");
    btns.className = "tileBtns";

    if (allowFlip && where==="bank"){
      const flipBtn = document.createElement("button");
      flipBtn.className = "miniBtn";
      flipBtn.textContent = "↔";
      flipBtn.title = "Flip tile";
      flipBtn.onclick = (e)=>{ e.stopPropagation(); flip(tile); render(); };
      btns.appendChild(flipBtn);
      wrap.ondblclick = ()=>{ flip(tile); render(); };
    }

    wrap.onclick = (e)=>{
      if (e.target && e.target.tagName === "BUTTON") return;
      if (where==="bank") setSelected(tile.id);
    };

    if (where==="bank"){
      wrap.addEventListener("dragstart", (e)=>{
        e.dataTransfer.setData("text/plain", tile.id);
        e.dataTransfer.effectAllowed = "move";
      });
    }

    wrap.appendChild(core);
    wrap.appendChild(btns);
    return wrap;
  }

  function render(){
    // Anchors
    const anchors = document.getElementById("anchors");
    if (showAnchors){
      anchors.style.display = "flex";
      document.getElementById("startAnchor").textContent = "START: " + expectedStart;
      document.getElementById("endAnchor").textContent = "END: " + expectedEnd;
    } else {
      anchors.style.display = "none";
    }

    // Open ends display
    const ends = getOpenEnds();
    leftValueEl.textContent = ends.left;
    rightValueEl.textContent = ends.right;

    // Train tiles
    trainEl.innerHTML = "";
    trainTiles.forEach(t => trainEl.appendChild(makeTileUI(t, "train")));

    // Bank tiles
    bankEl.innerHTML = "";
    bankTiles.forEach(t => bankEl.appendChild(makeTileUI(t, "bank")));

    renderProgress();
  }

  function shuffleBank(){
    bankTiles = shuffle(bankTiles);
    render();
  }

  function resetAll(){
    clearFeedback();
    selectedId = null;

    // Start the train with ONE tile (like a real domino start)
    const tiles = answerTiles.map(t => ({...t}));
    shuffle(tiles);

    trainTiles = [ tiles.shift() ]; // first tile on table
    bankTiles = tiles;              // rest in hand/bank

    render();
  }

  function checkTrain(){
    clearFeedback();

    if (bankTiles.length > 0){
      showFeedback("Play all tiles onto the train before checking.", "bad");
      return;
    }

    const wrong = [];
    for (let i=0;i<trainTiles.length-1;i++){
      if (!eq(trainTiles[i].right, trainTiles[i+1].left)) wrong.push(i);
    }

    // If anchors are shown, enforce correct start/end
    if (showAnchors){
      if (!eq(trainTiles[0].left, expectedStart)) wrong.push(-1);
      if (!eq(trainTiles[trainTiles.length-1].right, expectedEnd)) wrong.push(trainTiles.length-1);
    }

    if (wrong.length === 0){
      showFeedback("✅ Perfect train. Nicely played.", "ok");
      return;
    }

    const mid = wrong.filter(x=>x>=0);
    const parts = [];
    parts.push(`<b>Not quite.</b>`);
    if (mid.length){
      parts.push(`<div class="small mono">Mismatch after tile(s): ${mid.map(i=>i+1).join(", ")}</div>`);
    }
    if (showAnchors){
      if (wrong.includes(-1)) parts.push(`<div class="small mono">Start tile left side doesn’t match START.</div>`);
      if (wrong.includes(trainTiles.length-1)) parts.push(`<div class="small mono">End tile right side doesn’t match END.</div>`);
    }
    parts.push(`<div class="small">Remember: you can only play tiles on the ends (and flip if allowed).</div>`);
    showFeedback(parts.join(""), "bad");
  }

  // End drop zones
  function wireEndZone(el, side){
    el.addEventListener("dragover", (e)=>{ e.preventDefault(); el.classList.add("over"); });
    el.addEventListener("dragleave", ()=>el.classList.remove("over"));
    el.addEventListener("drop", (e)=>{
      e.preventDefault(); el.classList.remove("over");
      const id = e.dataTransfer.getData("text/plain");
      attemptPlay(id, side);
    });
    el.onclick = ()=>{
      if (selectedId) attemptPlay(selectedId, side);
    };
  }

  wireEndZone(leftEndEl, "left");
  wireEndZone(rightEndEl, "right");

  // Start game
  resetAll();

  document.getElementById("sub").textContent = allowFlip
    ? "Play tiles only on the LEFT or RIGHT end. Drag a tile to an end, or tap tile → tap an end. Double-click (or ↔) flips."
    : "Play tiles only on the LEFT or RIGHT end. Drag a tile to an end, or tap tile → tap an end.";
</script>
</body>
</html>
