<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Chain Dominoes – Play</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:#f8fafc;margin:0;padding:20px;}
  .card{max-width:980px;margin:auto;background:#fff;border:1px solid #e5e7eb;border-radius:16px;padding:16px;}
  h2{margin:0 0 6px 0;}
  .small{font-size:12px;color:#6b7280;}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;}
  button{padding:10px 14px;border-radius:12px;border:1px solid #d1d5db;background:#f9fafb;font-weight:750;cursor:pointer;}
  button.primary{background:#111827;color:#fff;border-color:#111827;}
  button.danger{background:#fff1f2;border-color:#fecdd3;}
  .divider{height:1px;background:#e5e7eb;margin:14px 0;}

  .anchorRow{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:10px;}
  .anchor{
    border:1px solid #d1d5db;border-radius:14px;padding:10px 12px;background:#f3f4f6;
    font-weight:850; flex:1 1 320px;
  }

  /* ===== Chain = single column (no overlap possible) ===== */
  .chainWrap{
    border:1px solid #e5e7eb;
    border-radius:14px;
    background:#fafafa;
    padding:10px;
  }
  .chain{
    display:flex;
    flex-direction:column;
    gap:10px;
  }
  .slot{
    border:2px dashed #cbd5e1;
    border-radius:14px;
    background:#f8fafc;
    min-height:78px;
    display:flex;
    align-items:stretch;
    justify-content:stretch;
    overflow:hidden;
  }
  .slot.over{border-color:#111827;}
  .slot.filled{border-style:solid;border-color:#e5e7eb;background:#fff;}
  .slotLabel{
    width:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:12px;
    color:#94a3b8;
    font-size:12px;
    font-weight:700;
  }

  /* ===== Tile visuals (same everywhere) ===== */
  .tile{
    width:100%;
    display:flex;
    align-items:stretch;
    gap:10px;
    padding:10px;
    background:#fff;
  }
  .tileCore{
    width:100%;
    display:flex;
    align-items:center;
    gap:10px;
    border:1px solid #d1d5db;
    border-radius:14px;
    padding:10px;
    background:#fff;
  }
  .half{
    flex:1 1 0;
    text-align:center;
    font-weight:850;
    padding:10px;
    border-radius:12px;
    background:#f3f4f6;
    min-width:0;
    word-break:break-word;
  }
  .sep{width:2px;height:44px;background:#e5e7eb;border-radius:2px;flex:0 0 auto;}
  .tileBtns{
    display:flex;
    gap:8px;
    align-items:center;
    flex:0 0 auto;
  }
  .miniBtn{
    border:1px solid #d1d5db;background:#f9fafb;border-radius:12px;
    padding:8px 10px;font-weight:900;cursor:pointer;
  }

  /* Drag handle feel */
  .draggable{cursor:grab; user-select:none;}
  .draggable:active{cursor:grabbing;}

  /* Selected tile (tap-to-place) */
  .selected{
    outline:3px solid #111827;
    outline-offset:2px;
  }

  /* ===== Bank = responsive grid ===== */
  .bankWrap{
    border:1px solid #e5e7eb;
    border-radius:14px;
    background:#fafafa;
    padding:10px;
  }
  .bankGrid{
    display:grid;
    grid-template-columns:repeat(2, minmax(0,1fr));
    gap:10px;
  }
  @media (max-width: 760px){
    .bankGrid{grid-template-columns:repeat(1, minmax(0,1fr));}
  }

  .feedback{margin-top:10px;padding:10px 12px;border-radius:12px;background:#f3f4f6;color:#111827;font-size:13px;}
  .ok{background:#ecfdf5;}
  .bad{background:#fff1f2;}
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;}
</style>
</head>
<body>

<div class="card">
  <div class="row">
    <div>
      <h2>Chain Dominoes</h2>
      <div class="small" id="sub">Drag tiles into the chain, or tap a tile then tap a slot.</div>
    </div>
    <div class="row" style="justify-content:flex-end;">
      <button onclick="shuffleBank()">Shuffle bank</button>
      <button class="danger" onclick="resetAll()">Reset</button>
      <button class="primary" onclick="checkChain()">Check</button>
    </div>
  </div>

  <div class="divider"></div>

  <div id="anchors" class="anchorRow" style="display:none;">
    <div class="anchor" id="startAnchor"></div>
    <div class="anchor" id="endAnchor"></div>
  </div>

  <div class="small" style="margin-bottom:6px;">Chain (top → bottom):</div>
  <div class="chainWrap">
    <div id="slots" class="chain"></div>
  </div>

  <div class="divider"></div>

  <div class="row" style="margin-bottom:6px;">
    <div class="small">Tile bank:</div>
    <div class="small">Tip: Tap tile → tap slot (touch-friendly).</div>
  </div>
  <div class="bankWrap">
    <div id="bank" class="bankGrid"></div>
  </div>

  <div id="feedback" class="feedback" style="display:none;"></div>
</div>

<script>
  function decodeB64Unicode(b64){
    try { return decodeURIComponent(escape(atob(b64))); } catch(e){ return null; }
  }
  function shuffle(arr){
    for (let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    return arr;
  }
  const norm = s => (s||"").trim().toLowerCase();
  const eq = (a,b) => norm(a) === norm(b);

  const m = (location.hash || "").match(/#p=([^&]+)/);
  if (!m) { document.getElementById("sub").textContent = "Missing game data in the link."; throw ""; }
  const raw = decodeB64Unicode(m[1]);
  if (!raw) { document.getElementById("sub").textContent = "Could not read game data."; throw ""; }

  const payload = JSON.parse(raw);
  const steps = (payload.steps || []).map(s => (s||"").trim()).filter(Boolean);
  const showAnchors = !!payload.showAnchors;
  const allowFlip = (payload.allowFlip !== false);

  if (steps.length < 3){
    document.getElementById("sub").textContent = "Invalid chain (needs at least 3 steps).";
    throw "";
  }

  // Answer tiles: consecutive steps
  const answerTiles = [];
  for (let i=0;i<steps.length-1;i++){
    answerTiles.push({ id: "t"+(i+1), left: steps[i], right: steps[i+1] });
  }

  const expectedStart = steps[0];
  const expectedEnd = steps[steps.length-1];

  // State
  let bankTiles = shuffle(answerTiles.map(t => ({...t})));
  let chain = Array(answerTiles.length).fill(null);
  let selectedId = null; // for tap-to-place

  const slotsEl = document.getElementById("slots");
  const bankEl = document.getElementById("bank");
  const fbEl = document.getElementById("feedback");

  function showFeedback(html, kind){
    fbEl.style.display = "block";
    fbEl.className = "feedback " + (kind || "");
    fbEl.innerHTML = html;
  }
  function clearFeedback(){
    fbEl.style.display = "none";
    fbEl.className = "feedback";
    fbEl.innerHTML = "";
  }

  function flipTileById(id){
    let t = bankTiles.find(x => x.id === id);
    if (t){ [t.left,t.right]=[t.right,t.left]; render(); return; }
    for (let i=0;i<chain.length;i++){
      if (chain[i] && chain[i].id === id){
        [chain[i].left,chain[i].right]=[chain[i].right,chain[i].left];
        render(); return;
      }
    }
  }

  function setSelected(id){
    selectedId = (selectedId === id) ? null : id;
    render();
  }

  function placeTileInSlot(id, idx){
    clearFeedback();

    // If slot has a tile, send it back to bank
    if (chain[idx]) bankTiles.push(chain[idx]);

    // From bank?
    const bi = bankTiles.findIndex(t => t.id === id);
    if (bi !== -1){
      chain[idx] = bankTiles.splice(bi,1)[0];
      selectedId = null;
      render();
      return;
    }

    // From another slot?
    const si = chain.findIndex(t => t && t.id === id);
    if (si !== -1){
      const moving = chain[si];
      chain[si] = null;
      chain[idx] = moving;
      selectedId = null;
      render();
      return;
    }
  }

  function returnTileToBank(slotIdx){
    if (!chain[slotIdx]) return;
    bankTiles.push(chain[slotIdx]);
    chain[slotIdx] = null;
    render();
  }

  function makeTileUI(tile, where, slotIdx){
    // Wrapper so we can highlight selection cleanly
    const wrap = document.createElement("div");
    wrap.className = "tile " + (where === "bank" ? "draggable" : "draggable");
    if (selectedId === tile.id) wrap.classList.add("selected");
    wrap.draggable = true;
    wrap.dataset.id = tile.id;

    const core = document.createElement("div");
    core.className = "tileCore";

    const L = document.createElement("div"); L.className="half"; L.textContent = tile.left;
    const sep = document.createElement("div"); sep.className="sep";
    const R = document.createElement("div"); R.className="half"; R.textContent = tile.right;

    core.appendChild(L); core.appendChild(sep); core.appendChild(R);

    const btns = document.createElement("div");
    btns.className = "tileBtns";

    if (allowFlip){
      const flip = document.createElement("button");
      flip.className = "miniBtn";
      flip.textContent = "↔";
      flip.title = "Flip tile";
      flip.onclick = (e)=>{ e.stopPropagation(); flipTileById(tile.id); };
      btns.appendChild(flip);
      wrap.ondblclick = ()=>flipTileById(tile.id);
    }

    if (where === "slot"){
      const back = document.createElement("button");
      back.className = "miniBtn";
      back.textContent = "↩";
      back.title = "Return to bank";
      back.onclick = (e)=>{ e.stopPropagation(); returnTileToBank(slotIdx); };
      btns.appendChild(back);
    }

    // Tap-to-place selection
    wrap.onclick = (e)=>{
      // Don’t toggle selection if clicking a button
      if (e.target && e.target.tagName === "BUTTON") return;
      setSelected(tile.id);
    };

    wrap.addEventListener("dragstart", (e)=>{
      e.dataTransfer.setData("text/plain", tile.id);
      e.dataTransfer.effectAllowed = "move";
    });

    wrap.appendChild(core);
    wrap.appendChild(btns);
    return wrap;
  }

  function render(){
    // Anchors
    const anchors = document.getElementById("anchors");
    if (showAnchors){
      anchors.style.display = "flex";
      document.getElementById("startAnchor").textContent = "START: " + expectedStart;
      document.getElementById("endAnchor").textContent = "END: " + expectedEnd;
    } else {
      anchors.style.display = "none";
    }

    // Slots (vertical)
    slotsEl.innerHTML = "";
    chain.forEach((tile, idx)=>{
      const slot = document.createElement("div");
      slot.className = "slot" + (tile ? " filled" : "");
      slot.dataset.slot = String(idx);

      slot.addEventListener("dragover", (e)=>{ e.preventDefault(); slot.classList.add("over"); });
      slot.addEventListener("dragleave", ()=>slot.classList.remove("over"));
      slot.addEventListener("drop", (e)=>{
        e.preventDefault(); slot.classList.remove("over");
        const id = e.dataTransfer.getData("text/plain");
        placeTileInSlot(id, idx);
      });

      // Tap-to-place: tap slot after selecting a tile
      slot.onclick = ()=>{
        if (selectedId) placeTileInSlot(selectedId, idx);
      };

      if (tile){
        slot.appendChild(makeTileUI(tile, "slot", idx));
      } else {
        const ph = document.createElement("div");
        ph.className = "slotLabel";
        ph.textContent = selectedId ? "Tap to place selected tile here" : ("Slot " + (idx+1));
        slot.appendChild(ph);
      }

      slotsEl.appendChild(slot);
    });

    // Bank (grid)
    bankEl.innerHTML = "";
    bankTiles.forEach(t => {
      const el = makeTileUI(t, "bank", -1);
      bankEl.appendChild(el);
    });
  }

  function shuffleBank(){
    bankTiles = shuffle(bankTiles);
    render();
  }

  function resetAll(){
    clearFeedback();
    selectedId = null;
    chain = Array(answerTiles.length).fill(null);
    bankTiles = shuffle(answerTiles.map(t => ({...t})));
    render();
  }

  function checkChain(){
    clearFeedback();

    if (chain.some(x => !x)){
      showFeedback("Fill every slot before checking.", "bad");
      return;
    }

    const wrongAfter = [];
    for (let i=0;i<chain.length-1;i++){
      if (!eq(chain[i].right, chain[i+1].left)) wrongAfter.push(i);
    }

    if (showAnchors){
      if (!eq(chain[0].left, expectedStart)) wrongAfter.push(-1);
      if (!eq(chain[chain.length-1].right, expectedEnd)) wrongAfter.push(chain.length-1);
    }

    if (wrongAfter.length === 0){
      showFeedback("✅ Nice! Chain rebuilt correctly.", "ok");
      return;
    }

    const parts = [];
    parts.push(`<b>Not quite.</b>`);
    const mid = wrongAfter.filter(x=>x>=0);
    if (mid.length){
      parts.push(`<div class="small mono">Mismatch after tile(s): ${mid.map(i=>i+1).join(", ")}</div>`);
    }
    if (showAnchors){
      if (wrongAfter.includes(-1)) parts.push(`<div class="small mono">Start tile left side doesn’t match START.</div>`);
      if (wrongAfter.includes(chain.length-1)) parts.push(`<div class="small mono">End tile right side doesn’t match END.</div>`);
    }
    parts.push(`<div class="small">Tip: swap positions (and flip tiles if enabled).</div>`);
    showFeedback(parts.join(""), "bad");
  }

  document.getElementById("sub").textContent = allowFlip
    ? "Drag tiles into the chain, or tap a tile then tap a slot. Double-click a tile (or ↔) to flip."
    : "Drag tiles into the chain, or tap a tile then tap a slot.";

  render();
</script>
</body>
</html>
